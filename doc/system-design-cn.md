# AI-Native ä»£ç åŠ©æ‰‹è®¾è®¡æ–‡æ¡£

## æ¦‚è¿°

æœ¬é¡¹ç›®æ„å»ºä¸€ä¸ªæç®€çš„ AI-Native ä»£ç åŠ©æ‰‹ç³»ç»Ÿï¼Œä¸“æ³¨äºæ ¸å¿ƒèƒ½åŠ›ï¼šç†è§£ã€æ‹†è§£å’Œæ‰§è¡Œã€‚ç³»ç»Ÿé‡‡ç”¨æœ€å°çº¦æŸè®¾è®¡ï¼Œæœ€å¤§åŒ–å‘æŒ¥ AI æ¨¡å‹çš„è‡ªä¸»èƒ½åŠ›ï¼Œæ”¯æŒå¤šç§ AI æ¨¡å‹ï¼Œä¸ä¾èµ–ç‰¹å®šçš„æ¡†æ¶çº¦å®šã€‚

## è®¾è®¡åŸåˆ™

### 1. AI-Native æ¶æ„
- AI æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œæ‹¥æœ‰å®Œå…¨çš„å†³ç­–æƒ
- æœ€å°åŒ–å¯¹ AI è¡Œä¸ºçš„çº¦æŸ
- ä¿¡ä»» AI çš„åˆ¤æ–­å’Œæ¨ç†èƒ½åŠ›

### 2. æ¨¡å‹æ— å…³æ€§
- ä¸ç»‘å®šç‰¹å®š AI æä¾›å•†
- æ”¯æŒæœ¬åœ°å’Œäº‘ç«¯æ¨¡å‹
- é€‚é…ä¸åŒæ¨¡å‹çš„èƒ½åŠ›å·®å¼‚

### 3. æç®€è®¾è®¡
- å»é™¤éå¿…è¦çš„çº¦æŸå’Œè§„åˆ™
- ä¸“æ³¨æ ¸å¿ƒåŠŸèƒ½ï¼šç†è§£ã€æ‹†è§£ã€æ‰§è¡Œ
- é¿å…è¿‡åº¦å·¥ç¨‹åŒ–

### 4. å¼€æ”¾æ¶æ„
- ä¸ä¾èµ– agents.md ç­‰çº¦å®šæ€§æ–‡ä»¶
- ä¸éµå¾ªç‰¹å®šçš„å¤–éƒ¨è§„èŒƒ
- æ”¯æŒè‡ªå®šä¹‰å·¥å…·å’Œæ‰©å±•

## ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLI å®¢æˆ·ç«¯    â”‚    â”‚  Rust å®¢æˆ·ç«¯   â”‚    â”‚  HTTP å®¢æˆ·ç«¯    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    AI Agent æœåŠ¡        â”‚
                    â”‚   (æ ¸å¿ƒä¸šåŠ¡é€»è¾‘)          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
    â”‚   æ¨¡å‹     â”‚        â”‚    å·¥å…·       â”‚        â”‚   æŒ‡æ ‡      â”‚
    â”‚ (Zhipu,   â”‚        â”‚ (æ–‡ä»¶æ“ä½œ,    â”‚        â”‚ (Prometheus â”‚
    â”‚ OpenAI,   â”‚        â”‚ å‘½ä»¤æ‰§è¡Œ,    â”‚        â”‚  å¯¼å‡º)      â”‚
    â”‚ ç­‰)       â”‚        â”‚ ç­‰)          â”‚        â”‚            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æœåŠ¡æ¶æ„

AI-Native ä»£ç åŠ©æ‰‹å·²è½¬æ¢ä¸ºç‹¬ç«‹æœåŠ¡ï¼Œæ”¯æŒå¤šç§æ¥å£ï¼š

#### 1. æœåŠ¡å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    AI Agent æœåŠ¡                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æœåŠ¡ API å±‚                                                â”‚
â”‚  â”œâ”€ Rust API (AiAgentApi trait)                           â”‚
â”‚  â”œâ”€ HTTP REST API (Axum æœåŠ¡å™¨)                           â”‚
â”‚  â””â”€ WebSocket API (å®æ—¶æ›´æ–°)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ ¸å¿ƒä¸šåŠ¡é€»è¾‘                                               â”‚
â”‚  â”œâ”€ ä»»åŠ¡ç†è§£ä¸è§„åˆ’                                         â”‚
â”‚  â”œâ”€ æ‰§è¡Œå¼•æ“                                               â”‚
â”‚  â”œâ”€ å·¥å…·ç®¡ç†                                               â”‚
â”‚  â””â”€ å¹¶å‘ä»»åŠ¡å¤„ç†                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºç¡€è®¾æ–½å±‚                                                 â”‚
â”‚  â”œâ”€ æŒ‡æ ‡æ”¶é›†                                               â”‚
â”‚  â”œâ”€ é”™è¯¯å¤„ç†                                               â”‚
â”‚  â”œâ”€ é…ç½®ç®¡ç†                                               â”‚
â”‚  â””â”€ å¥åº·ç›‘æ§                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. åŒæ¥å£è®¾è®¡

**Rust API æ¥å£ï¼š**
- ç›´æ¥è¿›ç¨‹å†…ä½¿ç”¨
- é›¶å¼€é”€é€šä¿¡
- ç±»å‹å®‰å…¨æ¥å£
- é€‚ç”¨äº Rust åº”ç”¨ç¨‹åº

**HTTP REST API æ¥å£ï¼š**
- è¯­è¨€æ— å…³è®¿é—®
- æ ‡å‡† RESTful ç«¯ç‚¹
- JSON è¯·æ±‚/å“åº”æ ¼å¼
- æ˜“äºä¸ä»»ä½•åº”ç”¨ç¨‹åºé›†æˆ

#### 3. ä»»åŠ¡å¤„ç†æµç¨‹

```
ç”¨æˆ·è¯·æ±‚ â†’ API å±‚ â†’ æœåŠ¡æ ¸å¿ƒ â†’ AI ç†è§£ â†’ æ‰§è¡Œè§„åˆ’ â†’ å·¥å…·æ‰§è¡Œ â†’ ç»“æœ â†’ API å“åº”
```

### æ ¸å¿ƒç»„ä»¶

#### 1. AI Agent æœåŠ¡ (AiAgentService)

åè°ƒæ‰€æœ‰æ“ä½œå¹¶æä¾› Rust API å’Œ HTTP æ¥å£çš„ä¸­å¤®æœåŠ¡ç»„ä»¶ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/service/core.rs`

```rust
pub struct AiAgentService {
    config: ServiceConfig,
    metrics: Arc<MetricsCollector>,
    agent: Arc<RwLock<TaskAgent>>,  // ä½¿ç”¨ TaskAgentï¼ˆé€šç”¨ä»»åŠ¡ä»£ç†ï¼‰
    active_tasks: Arc<RwLock<HashMap<String, Arc<RwLock<TaskContext>>>>,
    task_semaphore: Arc<Semaphore>,
    available_tools: Vec<String>,
}

impl AiAgentService {
    pub async fn new(
        service_config: ServiceConfig,
        agent_config: AgentConfig
    ) -> Result<Self, ServiceError> {
        // ä½¿ç”¨é…ç½®åˆå§‹åŒ–æœåŠ¡
    }

    pub async fn execute_task(&self, request: TaskRequest) -> Result<TaskResponse, ServiceError> {
        // å¸¦èµ„æºç®¡ç†çš„å¹¶å‘ä»»åŠ¡æ‰§è¡Œ
        let _permit = self.task_semaphore.acquire().await?;

        let task_id = request.task_id.clone()
            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());

        // é€šè¿‡ AI ä»£ç†æ‰§è¡Œä»»åŠ¡
        let result = self.agent.read().await
            .process_task(&request.task).await?;

        // æ”¶é›†æŒ‡æ ‡å¹¶è¿”å›å“åº”
        self.metrics.record_task_completion(
            execution_time,
            result.is_success()
        ).await;

        Ok(TaskResponse {
            task_id,
            status: TaskStatus::Completed,
            result: Some(result),
            metrics: self.metrics.get_metrics_snapshot().await,
            ..
        })
    }

    pub async fn execute_batch(&self, request: BatchTaskRequest) -> Result<BatchTaskResponse, ServiceError> {
        // å¤„ç†å¹¶å‘æ‰¹é‡ä»»åŠ¡æ‰§è¡Œ
        match request.mode {
            BatchExecutionMode::Parallel => {
                // ä½¿ç”¨å—æ§å¹¶è¡Œåº¦å¹¶å‘æ‰§è¡Œä»»åŠ¡
                let tasks = request.tasks.into_iter()
                    .map(|task| self.execute_task(task))
                    .collect::<Vec<_>>();

                let results = futures::future::join_all(tasks).await;
                // å¤„ç†ç»“æœå¹¶ç¼–è¯‘æ‰¹é‡å“åº”
            }
            BatchExecutionMode::Sequential => {
                // é€ä¸ªæ‰§è¡Œä»»åŠ¡
            }
        }
    }
}
```

#### 2. æœåŠ¡ API å±‚

æä¾› Rust API trait å’Œ HTTP REST ç«¯ç‚¹ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/service/api.rs`

```rust
#[async_trait]
pub trait AiAgentApi: Send + Sync {
    async fn execute_task(&self, request: TaskRequest) -> ServiceResult<TaskResponse>;
    async fn execute_batch(&self, request: BatchTaskRequest) -> ServiceResult<BatchTaskResponse>;
    async fn get_task_status(&self, task_id: &str) -> ServiceResult<TaskResponse>;
    async fn cancel_task(&self, task_id: &str) -> ServiceResult<()>;
    async fn get_service_status(&self) -> ServiceResult<ServiceStatus>;
    async fn get_metrics(&self) -> ServiceResult<MetricsSnapshot>;
}

// è¿›ç¨‹å†… API å®ç°
pub struct InProcessApi {
    service: Arc<AiAgentService>,
}

#[async_trait]
impl AiAgentApi for InProcessApi {
    async fn execute_task(&self, request: TaskRequest) -> ServiceResult<TaskResponse> {
        self.service.execute_task(request).await
    }
    // ... å…¶ä»–å®ç°
}

// HTTP å®¢æˆ·ç«¯å®ç°
pub struct HttpClientApi {
    client: reqwest::Client,
    base_url: String,
    api_key: Option<String>,
}

#[async_trait]
impl AiAgentApi for HttpClientApi {
    async fn execute_task(&self, request: TaskRequest) -> ServiceResult<TaskResponse> {
        let response = self.client
            .post(&format!("{}/api/v1/tasks", self.base_url))
            .json(&request)
            .send()
            .await?;

        response.json::<TaskResponse>().await
            .map_err(|e| ServiceError::NetworkError(e.to_string()))
    }
    // ... å…¶ä»–å®ç°
}
```

#### 3. HTTP æœåŠ¡å™¨

åŸºäº Axum çš„ HTTP æœåŠ¡å™¨ï¼Œæä¾› REST API ç«¯ç‚¹ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/server/main.rs`

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = ServiceConfig::from_env()?;
    let agent_config = AgentConfig::load_with_fallback("config.toml")?;

    let service = Arc::new(AiAgentService::new(config, agent_config).await?);

    let app = Router::new()
        .route("/health", get(health_check))
        .route("/api/v1/status", get(service_status))
        .route("/api/v1/metrics", get(get_metrics))
        .route("/api/v1/tools", get(list_tools))
        .route("/api/v1/tasks", post(execute_task))
        .route("/api/v1/tasks/batch", post(execute_batch))
        .route("/api/v1/tasks/:id", get(get_task_status))
        .route("/api/v1/tasks/:id", delete(cancel_task))
        .layer(
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods([Method::GET, Method::POST, Method::DELETE])
                .allow_headers(Any)
        )
        .layer(TraceLayer::new_for_http())
        .with_state(AppState { service });

    let listener = tokio::net::TcpListener::bind(&config.bind_address).await?;
    tracing::info!("AI Agent æœåŠ¡ç›‘å¬åœ°å€: {}", config.bind_address);

    axum::serve(listener, app).await?;
    Ok(())
}

// API ç«¯ç‚¹å¤„ç†å™¨
async fn execute_task(
    State(state): State<AppState>,
    Json(request): Json<TaskRequest>,
) -> Result<Json<TaskResponse>, ServiceError> {
    let response = state.service.execute_task(request).await?;
    Ok(Json(response))
}

async fn execute_batch(
    State(state): State<AppState>,
    Json(request): Json<BatchTaskRequest>,
) -> Result<Json<BatchTaskResponse>, ServiceError> {
    let response = state.service.execute_batch(request).await?;
    Ok(Json(response))
}
```

#### 4. æŒ‡æ ‡å’Œç›‘æ§

å…¨é¢çš„æŒ‡æ ‡æ”¶é›†å’Œç›‘æ§ç³»ç»Ÿã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/service/metrics_simple.rs`

```rust
pub struct MetricsCollector {
    start_time: Instant,
    metrics: Arc<RwLock<ServiceMetrics>>,
}

#[derive(Debug, Clone, Default)]
pub struct ServiceMetrics {
    pub total_tasks: u64,
    pub completed_tasks: u64,
    pub failed_tasks: u64,
    pub active_tasks: u64,
    pub total_execution_time: f64,
    pub task_execution_times: Vec<f64>,
    pub tool_usage: HashMap<String, u64>,
    pub error_counts: HashMap<String, u64>,
    pub system_metrics: SystemMetrics,
}

impl MetricsCollector {
    pub async fn record_task_start(&self) {
        let mut metrics = self.metrics.write().await;
        metrics.total_tasks += 1;
        metrics.active_tasks += 1;
    }

    pub async fn record_task_completion(&self, execution_time: f64, success: bool) {
        let mut metrics = self.metrics.write().await;

        if metrics.active_tasks > 0 {
            metrics.active_tasks -= 1;
        }

        if success {
            metrics.completed_tasks += 1;
        } else {
            metrics.failed_tasks += 1;
        }

        metrics.task_execution_times.push(execution_time);
        // ä»…ä¿ç•™æœ€è¿‘ 1000 æ¬¡æ‰§è¡Œæ—¶é—´
        if metrics.task_execution_times.len() > 1000 {
            metrics.task_execution_times.remove(0);
        }
    }

    pub async fn get_metrics_snapshot(&self) -> MetricsSnapshot {
        let metrics = self.metrics.read().await;
        MetricsSnapshot {
            uptime_seconds: self.start_time.elapsed().as_secs(),
            total_tasks: metrics.total_tasks,
            completed_tasks: metrics.completed_tasks,
            failed_tasks: metrics.failed_tasks,
            active_tasks: metrics.active_tasks,
            average_execution_time_seconds: if metrics.completed_tasks > 0 {
                metrics.total_execution_time / metrics.completed_tasks as f64
            } else {
                0.0
            },
            tool_usage: metrics.tool_usage.clone(),
            error_counts: metrics.error_counts.clone(),
            system_metrics: metrics.system_metrics.clone(),
        }
    }
}
```

#### 5. AI ç†è§£å¼•æ“ (PlanningEngine)

è´Ÿè´£ç†è§£å’Œåˆ†æç”¨æˆ·ä»»åŠ¡ï¼Œåˆ¶å®šæ‰§è¡Œç­–ç•¥ã€‚é›†æˆæç¤ºè¯å·¥ç¨‹ç³»ç»Ÿã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/understanding.rs` (186è¡Œï¼Œé‡æ„å)

```rust
pub struct PlanningEngine {
    model: Arc<dyn LanguageModel>,
    prompt_template: PromptTemplate,  // æç¤ºè¯æ¨¡æ¿ç³»ç»Ÿ
}

impl PlanningEngine {
    // ä½¿ç”¨é»˜è®¤æ¨¡æ¿åˆ›å»º
    pub fn new(model: Arc<dyn LanguageModel>) -> Self {
        Self {
            model,
            prompt_template: PromptTemplate::default(),
        }
    }

    // ä½¿ç”¨è‡ªå®šä¹‰æ¨¡æ¿åˆ›å»º
    pub fn with_template(model: Arc<dyn LanguageModel>, template: PromptTemplate) -> Self {
        Self {
            model,
            prompt_template: template,
        }
    }

    // åˆ†æä»»åŠ¡ï¼ˆè‡ªåŠ¨æ¨æ–­ç±»å‹ï¼‰
    pub async fn understand_task(&self, request: &str) -> Result<TaskPlan, AgentError> {
        self.understand_task_with_type(request, None).await
    }

    // åˆ†æä»»åŠ¡ï¼ˆæŒ‡å®šç±»å‹ï¼‰
    pub async fn understand_task_with_type(
        &self,
        request: &str,
        task_type: Option<&str>,
    ) -> Result<TaskPlan, AgentError> {
        let prompt = self.build_understanding_prompt(request, task_type);
        let response = self.model.complete(&prompt).await?;
        self.parse_task_plan(&response.content)
    }

    // ä½¿ç”¨æç¤ºè¯æ¨¡æ¿ç³»ç»Ÿæ„å»ºæç¤ºè¯
    fn build_understanding_prompt(&self, request: &str, task_type: Option<&str>) -> String {
        let mut builder = PromptBuilder::new(self.prompt_template.clone());

        // è®¾ç½®ä»»åŠ¡ç±»å‹ï¼ˆæ˜¾å¼æˆ–æ¨æ–­ï¼‰
        if let Some(tt) = task_type {
            builder = builder.task_type(tt);
        } else {
            let inferred_type = self.infer_task_type(request);
            if let Some(tt) = inferred_type {
                builder = builder.task_type(&tt);
            }
        }

        builder.build(request)
    }

    // æ¨æ–­ä»»åŠ¡ç±»å‹ï¼ˆ9ç§åœºæ™¯ï¼‰
    fn infer_task_type(&self, request: &str) -> Option<String> {
        let lower = request.to_lowercase();
        if lower.contains("test") { Some("testing".to_string()) }
        else if lower.contains("refactor") { Some("refactoring".to_string()) }
        else if lower.contains("debug") || lower.contains("fix") { Some("debugging".to_string()) }
        else if lower.contains("document") { Some("documentation".to_string()) }
        else if lower.contains("optimize") { Some("optimization".to_string()) }
        else if lower.contains("design") { Some("architecture".to_string()) }
        else if lower.contains("read") || lower.contains("file") { Some("file_operations".to_string()) }
        else if lower.contains("run") || lower.contains("command") { Some("command_execution".to_string()) }
        else if lower.contains("create") || lower.contains("generate") { Some("code_generation".to_string()) }
        else { None }
    }
}
```

**é‡æ„æ”¹è¿›**:
- âœ… é›†æˆæç¤ºè¯å·¥ç¨‹ç³»ç»Ÿ
- âœ… æ”¯æŒè‡ªå®šä¹‰æ¨¡æ¿
- âœ… è‡ªåŠ¨ä»»åŠ¡ç±»å‹æ¨æ–­
- âœ… 9ç§é¢„å®šä¹‰åœºæ™¯
- âœ… ä» agent.rs åˆ†ç¦»å‡ºæ¥ï¼ˆèŒè´£æ¸…æ™°ï¼‰

è¯¦è§ï¼š[æç¤ºè¯å·¥ç¨‹æ–‡æ¡£](./PROMPT_ENGINEERING.md)

#### 2. AI æ‰§è¡Œå¼•æ“ (ExecutionEngine)

æ ¹æ®ç†è§£ç»“æœè‡ªä¸»æ‰§è¡Œä»»åŠ¡ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/execution.rs`

```rust
pub struct ExecutionEngine {
    model: Arc<dyn LanguageModel>,
    tools: Arc<Mutex<ToolRegistry>>,
    config: ExecutionConfig,
}

impl ExecutionEngine {
    pub async fn execute(&self, task_id: &str, plan: TaskPlan) -> Result<ExecutionResult, AgentError> {
        loop {
            let decision = self.make_execution_decision(&plan).await?;

            match decision.action_type {
                Action::UseTool(tool_call) => {
                    let result = self.tools.execute(tool_call).await?;
                    self.context.add_result(result);
                }
                Action::Complete(summary) => {
                    return Ok(ExecutionResult::success(summary));
                }
                Action::Continue => {
                    // ç»§ç»­æ‰§è¡Œå¾ªç¯
                }
            }
        }
    }

    async fn make_execution_decision(&self, plan: &TaskPlan) -> Result<ExecutionDecision, AgentError> {
        let prompt = self.build_execution_prompt(plan);
        let response = self.model.complete_with_tools(&prompt, &self.get_tool_definitions()).await?;
        self.parse_decision(&response)
    }
}
```

#### 3. å·¥å…·æ³¨å†Œç³»ç»Ÿ (ToolRegistry)

ç®¡ç†å’Œæ‰§è¡Œå„ç§å·¥å…·ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/tools.rs`

```rust
pub trait Tool {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn parameters(&self) -> Vec<Parameter>;
    async fn execute(&self, args: &ToolArgs) -> Result<ToolResult, ToolError>;
}

pub struct ToolRegistry {
    tools: HashMap<String, Box<dyn Tool>>,
}

impl ToolRegistry {
    pub fn register<T: Tool + 'static>(&mut self, tool: T) {
        self.tools.insert(tool.name().to_string(), Box::new(tool));
    }

    pub async fn execute(&self, tool_call: ToolCall) -> Result<ToolResult, ToolError> {
        let tool = self.tools.get(&tool_call.name)
            .ok_or_else(|| ToolError::ToolNotFound(tool_call.name.clone()))?;
        tool.execute(&tool_call.args).await
    }
}
```

## æ ¸å¿ƒåŠŸèƒ½è®¾è®¡

### 0. æç¤ºè¯å·¥ç¨‹ç³»ç»Ÿ (æ–°å¢)

çµæ´»çš„æç¤ºè¯æ¨¡æ¿ç³»ç»Ÿï¼Œå‚è€ƒ OpenAI Codex å’Œ Roo-Code æœ€ä½³å®è·µã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/prompts.rs` (300è¡Œ)

#### æ¶æ„è®¾è®¡

```rust
// åˆ†å±‚æç¤ºè¯æ¨¡æ¿
pub struct PromptTemplate {
    pub global: GlobalTemplate,              // å…¨å±€æ¨¡æ¿
    pub project: Option<ProjectRules>,       // é¡¹ç›®è§„åˆ™
    pub scenarios: HashMap<String, ScenarioPrompt>, // åœºæ™¯æç¤ºè¯
}

// å…¨å±€æ¨¡æ¿
pub struct GlobalTemplate {
    pub system_role: String,                 // ç³»ç»Ÿè§’è‰²
    pub output_format: OutputFormat,         // è¾“å‡ºæ ¼å¼
    pub constraints: Vec<String>,            // é€šç”¨çº¦æŸ
}

// é¡¹ç›®è§„åˆ™
pub struct ProjectRules {
    pub tech_stack: Vec<String>,             // æŠ€æœ¯æ ˆ
    pub conventions: Vec<String>,            // ç¼–ç è§„èŒƒ
    pub context: Option<String>,             // é¡¹ç›®ä¸Šä¸‹æ–‡
    pub architecture: Option<String>,        // æ¶æ„è¯´æ˜
}

// åœºæ™¯æç¤ºè¯
pub struct ScenarioPrompt {
    pub name: String,                        // åœºæ™¯åç§°
    pub description: String,                 // åœºæ™¯æè¿°
    pub instructions: Vec<String>,           // å…·ä½“æŒ‡ä»¤
    pub output_structure: Option<String>,    // è¾“å‡ºç»“æ„
    pub examples: Vec<PromptExample>,        // Few-shot ç¤ºä¾‹
}

// æµå¼æ„å»ºå™¨
pub struct PromptBuilder {
    template: PromptTemplate,
    task_type: Option<String>,
    context: HashMap<String, String>,
}
```

#### æ ¸å¿ƒç‰¹æ€§

- **åˆ†å±‚ç»“æ„**: å…¨å±€æ¨¡æ¿ + é¡¹ç›®è§„åˆ™ + åœºæ™¯æŒ‡ä»¤
- **å¤–ç½®é…ç½®**: YAML æ–‡ä»¶é…ç½®ï¼Œæ— éœ€ä¿®æ”¹ä»£ç 
- **åœºæ™¯æ”¯æŒ**: 9+ é¢„å®šä¹‰åœºæ™¯ï¼ˆä»£ç ç”Ÿæˆã€é‡æ„ã€è°ƒè¯•ç­‰ï¼‰
- **åŠ¨æ€åŠ è½½**: è¿è¡Œæ—¶åŠ è½½å’Œåˆ‡æ¢æ¨¡æ¿
- **æ™ºèƒ½æ¨æ–­**: è‡ªåŠ¨è¯†åˆ«ä»»åŠ¡ç±»å‹
- **å¯æ‰©å±•**: è½»æ¾æ·»åŠ è‡ªå®šä¹‰åœºæ™¯

#### å†…ç½®åœºæ™¯

1. **code_generation** - ä»£ç ç”Ÿæˆ
2. **refactoring** - ä»£ç é‡æ„
3. **debugging** - è°ƒè¯•ä¿®å¤
4. **testing** - æµ‹è¯•ç¼–å†™
5. **documentation** - æ–‡æ¡£ç¼–å†™
6. **architecture** - æ¶æ„è®¾è®¡
7. **optimization** - æ€§èƒ½ä¼˜åŒ–
8. **file_operations** - æ–‡ä»¶æ“ä½œ
9. **command_execution** - å‘½ä»¤æ‰§è¡Œ

#### ä½¿ç”¨ç¤ºä¾‹

```rust
// ä½¿ç”¨é»˜è®¤æ¨¡æ¿
let engine = PlanningEngine::new(model);
let plan = engine.understand_task("åˆ›å»ºé…ç½®åŠ è½½å™¨").await?;

// ä½¿ç”¨è‡ªå®šä¹‰æ¨¡æ¿
let template = PromptTemplate::from_file("prompts/rust-project.yaml")?;
let engine = PlanningEngine::with_template(model, template);

// æŒ‡å®šä»»åŠ¡ç±»å‹
let plan = engine
    .understand_task_with_type("ä¼˜åŒ–æ€§èƒ½", Some("optimization"))
    .await?;

// åŠ¨æ€æ„å»ºæç¤ºè¯
let prompt = PromptBuilder::new(template)
    .task_type("code_generation")
    .context("language", "Rust")
    .build("åˆ›å»ºå¼‚æ­¥æ–‡ä»¶è¯»å–å‡½æ•°");
```

è¯¦è§ï¼š[æç¤ºè¯å·¥ç¨‹æ–‡æ¡£](./PROMPT_ENGINEERING.md)

### 1. ä»»åŠ¡ç†è§£

AI æ¨¡å‹è‡ªä¸»ç†è§£ç”¨æˆ·æ„å›¾ï¼Œä¸å—æ ¼å¼çº¦æŸã€‚ä½¿ç”¨æç¤ºè¯å·¥ç¨‹ç³»ç»Ÿå¢å¼ºç†è§£èƒ½åŠ›ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/types.rs`

```rust
pub struct TaskPlan {
    pub understanding: String,
    pub approach: String,
    pub complexity: TaskComplexity,
    pub estimated_steps: Option<u32>,
    pub requirements: Vec<String>,
}

pub enum TaskComplexity {
    Simple,    // å•æ­¥æ“ä½œ
    Moderate,  // éœ€è¦å‡ ä¸ªæ­¥éª¤
    Complex,   // éœ€è¦è¯¦ç»†è§„åˆ’
}
```

### 2. è‡ªä¸»æ‰§è¡Œ

AI æ¨¡å‹æ ¹æ®ç†è§£ç»“æœè‡ªä¸»å†³å®šæ‰§è¡Œç­–ç•¥ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/types.rs`

```rust
pub struct ExecutionDecision {
    pub action_type: ActionType,
    pub reasoning: String,
    pub confidence: f32,
}

pub enum Action {
    UseTool(ToolCall),
    Complete(String),
    Continue,
    AskClarification(String),
}

pub struct ToolCall {
    pub name: String,
    pub args: ToolArgs,
}
```

### 3. å·¥å…·ç³»ç»Ÿ

æä¾›åŸºç¡€å·¥å…·ï¼Œæ”¯æŒæ‰©å±•ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/tools.rs`

```rust
// åŸºç¡€æ–‡ä»¶æ“ä½œå·¥å…·
pub struct ReadFileTool;
impl Tool for ReadFileTool {
    fn name(&self) -> &str { "read_file" }
    fn description(&self) -> &str { "è¯»å–æ–‡ä»¶å†…å®¹" }
    fn parameters(&self) -> Vec<Parameter> {
        vec![
            Parameter::required("path", "è¦è¯»å–çš„æ–‡ä»¶è·¯å¾„")
        ]
    }
    async fn execute(&self, args: &ToolArgs) -> Result<ToolResult, ToolError> {
        let path = args.get_string("path")?;
        let content = tokio::fs::read_to_string(path).await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        Ok(ToolResult::text(content))
    }
}

// å‘½ä»¤æ‰§è¡Œå·¥å…·
pub struct RunCommandTool;
impl Tool for RunCommandTool {
    fn name(&self) -> &str { "run_command" }
    fn description(&self) -> &str { "æ‰§è¡Œ shell å‘½ä»¤" }
    fn parameters(&self) -> Vec<Parameter> {
        vec![
            Parameter::required("command", "è¦æ‰§è¡Œçš„å‘½ä»¤"),
            Parameter::optional("working_dir", "å·¥ä½œç›®å½•"),
        ]
    }
    async fn execute(&self, args: &ToolArgs) -> Result<ToolResult, ToolError> {
        let command = args.get_string("command")?;
        let working_dir = args.get_string("working_dir").ok();
        let output = self.execute_command(command, working_dir).await?;
        Ok(ToolResult::text(output))
    }
}
```

## æ¨¡å‹é€‚é…ç³»ç»Ÿ

æ”¯æŒå¤šç§ AI æ¨¡å‹ï¼Œä¸ç»‘å®šç‰¹å®šæä¾›å•†ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/models.rs`

```rust
pub trait LanguageModel: Send + Sync {
    async fn complete(&self, prompt: &str) -> Result<ModelResponse, ModelError>;
    async fn complete_with_tools(&self, prompt: &str, tools: &[ToolDefinition]) -> Result<ModelResponse, ModelError>;
    fn model_name(&self) -> &str;
    fn supports_tools(&self) -> bool;
}

// OpenAI æ¨¡å‹é€‚é…
pub struct OpenAIModel {
    client: reqwest::Client,
    model: String,
}

impl LanguageModel for OpenAIModel {
    async fn complete(&self, prompt: &str) -> Result<ModelResponse, ModelError> {
        // å®ç° OpenAI API è°ƒç”¨
    }

    fn supports_tools(&self) -> bool { true }
}

// æ™ºè°±æ¨¡å‹é€‚é…
pub struct ZhipuModel {
    client: reqwest::Client,
    model: String,
}

impl LanguageModel for ZhipuModel {
    async fn complete(&self, prompt: &str) -> Result<ModelResponse, ModelError> {
        // å®ç°æ™ºè°± API è°ƒç”¨
    }

    fn supports_tools(&self) -> bool { true }
}

// æœ¬åœ°æ¨¡å‹é€‚é…ï¼ˆå¦‚ Ollamaï¼‰
pub struct LocalModel {
    endpoint: String,
    model: String,
}

impl LanguageModel for LocalModel {
    async fn complete(&self, prompt: &str) -> Result<ModelResponse, ModelError> {
        // å®ç°æœ¬åœ°æ¨¡å‹ API è°ƒç”¨
    }

    fn supports_tools(&self) -> bool {
        // æŸäº›æœ¬åœ°æ¨¡å‹å¯èƒ½ä¸æ”¯æŒå·¥å…·è°ƒç”¨
        self.model_supports_tools()
    }
}
```

## å¼‚å¸¸å¤„ç†

ç®€å•ä½†å¯é çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/errors.rs`

```rust
pub enum AgentError {
    ModelError(ModelError),
    ToolError(ToolError),
    NetworkError(String),
    TimeoutError,
    UnknownError(String),
}

pub struct ErrorHandler {
    max_retries: u32,
    retry_delay: Duration,
}

impl ErrorHandler {
    pub async fn handle_with_retry<F, T>(&self, operation: F) -> Result<T, AgentError>
    where
        F: Fn() -> Pin<Box<dyn Future<Output = Result<T, AgentError>> + Send>>,
    {
        let mut last_error = None;

        for attempt in 0..=self.max_retries {
            match operation().await {
                Ok(result) => return Ok(result),
                Err(error) => {
                    last_error = Some(error.clone());

                    if attempt < self.max_retries && self.should_retry(&error) {
                        tokio::time::sleep(self.retry_delay * (attempt + 1)).await;
                        continue;
                    } else {
                        break;
                    }
                }
            }
        }

        Err(last_error.unwrap_or(AgentError::UnknownError("æœªçŸ¥é”™è¯¯".to_string())))
    }
}
```

## é…ç½®ç³»ç»Ÿ

çµæ´»çš„é…ç½®ï¼Œæ”¯æŒä¸åŒä½¿ç”¨åœºæ™¯ã€‚

**æ–‡ä»¶ä½ç½®ï¼š** `src/config.rs`

```rust
#[derive(Debug, Clone)]
pub struct AgentConfig {
    pub model: ModelConfig,
    pub tools: ToolConfig,
    pub execution: ExecutionConfig,
    pub safety: SafetyConfig,
}

#[derive(Debug, Clone)]
pub struct ModelConfig {
    pub provider: ModelProvider,
    pub model_name: String,
    pub api_key: Option<String>,
    pub endpoint: Option<String>,
    pub max_tokens: u32,
    pub temperature: f32,
}

#[derive(Debug, Clone)]
pub enum ModelProvider {
    OpenAI,
    Anthropic,
    Zhipu,
    Local(String), // è‡ªå®šä¹‰ç«¯ç‚¹
}
```

## ä½¿ç”¨ç¤ºä¾‹

### æœåŠ¡æ¶æ„ä½¿ç”¨

#### 1. HTTP æœåŠ¡éƒ¨ç½²

**å¯åŠ¨ HTTP æœåŠ¡ï¼š**

```bash
# æ„å»ºå¹¶è¿è¡Œ HTTP æœåŠ¡å™¨
cargo run --bin ai-agent-server

# æˆ–ä½¿ç”¨ Docker
docker build -t ai-agent-service .
docker run -p 8080:8080 ai-agent-service
```

**HTTP API ä½¿ç”¨ï¼š**

```bash
# é€šè¿‡ HTTP æ‰§è¡Œä»»åŠ¡
curl -X POST http://localhost:8080/api/v1/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "task": "åˆ†ææ­¤é¡¹ç›®å¹¶åˆ›å»ºæ‘˜è¦",
    "priority": "high"
  }'

# è·å–æœåŠ¡çŠ¶æ€
curl http://localhost:8080/api/v1/status

# è·å–æŒ‡æ ‡
curl http://localhost:8080/api/v1/metrics
```

#### 2. Rust API é›†æˆ

```rust
use ai_agent::{
    service::{AiAgentService, ServiceConfig, AiAgentClient, ApiClientBuilder},
    config::AgentConfig
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºæœåŠ¡å®ä¾‹
    let service = Arc::new(AiAgentService::new(
        ServiceConfig::default(),
        AgentConfig::load_with_fallback("config.toml")?
    ).await?);

    // åˆ›å»ºè¿›ç¨‹å†…å®¢æˆ·ç«¯
    let client = AiAgentClient::new(ApiClientBuilder::in_process(service));

    // æ‰§è¡Œç®€å•ä»»åŠ¡
    let response = client.execute_simple_task("åˆ›å»ºä¸€ä¸ª Hello World ç¨‹åº").await?;
    println!("ç»“æœ: {}", response.result.unwrap().summary);

    Ok(())
}
```

### åŸºç¡€ CLI ä½¿ç”¨

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆå§‹åŒ–é…ç½®
    let config = AgentConfig::from_file("config.toml")?;

    // 2. åˆ›å»º AI æ¨¡å‹
    let model: Box<dyn LanguageModel> = match config.model.provider {
        ModelProvider::OpenAI => Box::new(OpenAIModel::new(config.model)?),
        ModelProvider::Anthropic => Box::new(AnthropicModel::new(config.model)?),
        ModelProvider::Zhipu => Box::new(ZhipuModel::new(config.model)?),
        ModelProvider::Local(endpoint) => Box::new(LocalModel::new(config.model, endpoint)?),
    };

    // 3. åˆ›å»º Agent
    let mut agent = CodeAgent::new(model, config)?;

    // 4. æ³¨å†Œå·¥å…·
    agent.register_tool(ReadFileTool).await;
    agent.register_tool(WriteFileTool).await;
    agent.register_tool(RunCommandTool).await;

    // 5. æ‰§è¡Œä»»åŠ¡
    let result = agent.process_task("è¯»å– package.json å¹¶æ·»åŠ æµ‹è¯•è„šæœ¬").await?;

    println!("ç»“æœ: {}", result.summary);
    Ok(())
}
```

### é«˜çº§ä½¿ç”¨ - è‡ªå®šä¹‰å·¥å…·

```rust
// è‡ªå®šä¹‰ Git å·¥å…·
pub struct GitStatusTool;

impl Tool for GitStatusTool {
    fn name(&self) -> &str { "git_status" }
    fn description(&self) -> &str { "æ£€æŸ¥ git ä»“åº“çŠ¶æ€" }
    fn parameters(&self) -> Vec<Parameter> {
        vec![
            Parameter::optional("path", "ä»“åº“è·¯å¾„", "./")
        ]
    }

    async fn execute(&self, args: &ToolArgs) -> Result<ToolResult, ToolError> {
        let path = args.get_string("path").unwrap_or("./");
        let output = tokio::process::Command::new("git")
            .args(&["status", "--porcelain"])
            .current_dir(path)
            .output()
            .await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;

        let status = String::from_utf8_lossy(&output.stdout);
        Ok(ToolResult::json(json!({
            "status": if output.status.success() { "success" } else { "error" },
            "output": status,
            "has_changes": !status.trim().is_empty()
        })))
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰å·¥å…·
let mut agent = CodeAgent::new(model, config)?;
agent.register_tool(GitStatusTool).await;
```

## å¼€å‘è¿›åº¦

### âœ… ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒæ¡†æ¶ - å·²å®Œæˆ
- âœ… æ ¸å¿ƒ trait å®šä¹‰
- âœ… åŸºç¡€ AI æ¨¡å‹æ¥å£
- âœ… ç®€å•çš„å·¥å…·æ³¨å†Œç³»ç»Ÿ
- âœ… åŸºç¡€å¼‚å¸¸å¤„ç†æ¡†æ¶
- âœ… ç†è§£å¼•æ“å®ç°
- âœ… æ‰§è¡Œå¼•æ“å®ç°
- âœ… åŸºç¡€å·¥å…·ï¼ˆæ–‡ä»¶æ“ä½œã€å‘½ä»¤æ‰§è¡Œï¼‰
- âœ… ç”¨äºæµ‹è¯•çš„ Mock æ¨¡å‹
- âœ… å¤šæ¨¡å‹æ”¯æŒç»“æ„

### ğŸš§ ç¬¬äºŒé˜¶æ®µï¼šæ¨¡å‹æ”¯æŒ - è¿›è¡Œä¸­
- âœ… æ¨¡å‹æä¾›å•†ç»“æ„ï¼ˆOpenAIã€Anthropicã€Zhipuã€Localï¼‰
- âœ… æ¨¡å‹èƒ½åŠ›æ£€æµ‹ç³»ç»Ÿ
- âœ… æ¨¡å‹åˆ‡æ¢æœºåˆ¶ç»“æ„
- âš ï¸ OpenAI æ¨¡å‹é›†æˆï¼ˆå ä½ç¬¦ï¼‰
- âš ï¸ Anthropic æ¨¡å‹é›†æˆï¼ˆå ä½ç¬¦ï¼‰
- âš ï¸ Zhipu æ¨¡å‹é›†æˆï¼ˆå ä½ç¬¦ï¼‰
- âš ï¸ æœ¬åœ°æ¨¡å‹é›†æˆï¼ˆå ä½ç¬¦ï¼‰

### âœ… ç¬¬ä¸‰é˜¶æ®µï¼šæœåŠ¡æ¶æ„ - å·²å®Œæˆ
- âœ… æœåŠ¡å¯¼å‘æ¶æ„è®¾è®¡
- âœ… åŒæ¥å£ç³»ç»Ÿï¼ˆRust API + HTTP RESTï¼‰
- âœ… å¸¦èµ„æºç®¡ç†çš„å¹¶å‘ä»»åŠ¡å¤„ç†
- âœ… å…¨é¢çš„æŒ‡æ ‡æ”¶é›†å’Œç›‘æ§
- âœ… åŸºäº Axum çš„ HTTP æœåŠ¡å™¨å®ç°
- âœ… å¸¦è¿›ç¨‹å†…å’Œ HTTP å®¢æˆ·ç«¯çš„æœåŠ¡ API trait
- âœ… å¼‚å¸¸å¤„ç†å’ŒæœåŠ¡ç‰¹å®šç±»å‹
- âœ… æœåŠ¡éƒ¨ç½²çš„é…ç½®ç®¡ç†
- âœ… Docker å®¹å™¨åŒ–å’Œéƒ¨ç½²è®¾ç½®
- âœ… API æ–‡æ¡£å’Œä½¿ç”¨ç¤ºä¾‹
- âœ… å¥åº·ç›‘æ§å’ŒæŒ‡æ ‡ç«¯ç‚¹

### ğŸ“‹ ç¬¬å››é˜¶æ®µï¼šæ‰©å±•åŠŸèƒ½ - å¾…åŠ
- æ›´å¤šç¼–ç¨‹å·¥å…·ï¼ˆGitã€åŒ…ç®¡ç†å™¨ç­‰ï¼‰
- å·¥å…·æ’ä»¶ç³»ç»Ÿ
- è‡ªå®šä¹‰å·¥å…·å¼€å‘æŒ‡å—
- WebSocket å®æ—¶æ›´æ–°
- é«˜çº§è®¤è¯å’Œæˆæƒ

### ğŸ“‹ ç¬¬äº”é˜¶æ®µï¼šç”¨æˆ·ä½“éªŒ - å¾…åŠ
- CLI ç•Œé¢ä¼˜åŒ–
- è¿›åº¦æ˜¾ç¤ºå’Œä»»åŠ¡ç›‘æ§
- é…ç½®ç®¡ç†å·¥å…·
- æœåŠ¡ç®¡ç†çš„ Web ä»ªè¡¨æ¿

## æŠ€æœ¯æ ˆ

- **è¯­è¨€**: Rustï¼ˆæ€§èƒ½ã€å†…å­˜å®‰å…¨ã€å¹¶å‘ï¼‰
- **å¼‚æ­¥è¿è¡Œæ—¶**: Tokio
- **HTTP å®¢æˆ·ç«¯**: Reqwest
- **HTTP æœåŠ¡å™¨**: Axumï¼ˆç”¨äº REST API æœåŠ¡ï¼‰
- **JSON å¤„ç†**: Serde
- **é…ç½®**: TOML
- **CLI**: Clap
- **æ—¥å¿—**: Tracing
- **æŒ‡æ ‡**: Metrics crate ä¸ Prometheus å¯¼å‡ºå™¨
- **Web æ¡†æ¶**: Tower ç”¨äº HTTP ä¸­é—´ä»¶
- **åºåˆ—åŒ–**: Serde JSON ç”¨äº API é€šä¿¡
- **å®¹å™¨åŒ–**: Docker å¤šé˜¶æ®µæ„å»º
- **ç›‘æ§**: Prometheus + Grafana é›†æˆ
- **å¼‚æ­¥ Trait**: async-trait ç”¨äº API trait å®šä¹‰

## æˆåŠŸæŒ‡æ ‡

### âœ… å·²å®ç°åŠŸèƒ½
- [x] å¤šæä¾›å•†æ¨¡å‹æ”¯æŒç»“æ„
- [x] åŸºç¡€å·¥å…·ç³»ç»Ÿï¼ŒåŒ…å« 4 ä¸ªå·¥å…·ï¼ˆread_fileã€write_fileã€run_commandã€list_filesï¼‰
- [x] ç†è§£å¼•æ“å®ç°
- [x] æ‰§è¡Œå¼•æ“å®ç°
- [x] é”™è¯¯å¤„ç†æ¡†æ¶
- [x] é…ç½®ç®¡ç†
- [x] CLI ç•Œé¢
- [x] ä»»åŠ¡å¤„ç†å·¥ä½œæµ
- [x] **å¸¦åŒæ¥å£çš„æœåŠ¡å¯¼å‘æ¶æ„**
- [x] **å¸¦ç»¼åˆç«¯ç‚¹çš„ HTTP REST API**
- [x] **ç”¨äºè¿›ç¨‹å†…ä½¿ç”¨çš„ Rust API åº“**
- [x] **å¸¦èµ„æºç®¡ç†çš„å¹¶å‘ä»»åŠ¡å¤„ç†**
- [x] **æŒ‡æ ‡æ”¶é›†å’Œç›‘æ§ç³»ç»Ÿ**
- [x] **Docker éƒ¨ç½²é…ç½®**
- [x] **å¥åº·ç›‘æ§å’ŒçŠ¶æ€ç«¯ç‚¹**
- [x] **æ‰¹é‡ä»»åŠ¡æ‰§è¡Œæ”¯æŒ**
- [x] **å®æ—¶ä»»åŠ¡è·Ÿè¸ªåŠŸèƒ½**

### ğŸ“Š å½“å‰çŠ¶æ€
- **æ¶æ„**: âœ… å®Œæ•´ä¸”åŠŸèƒ½æ­£å¸¸çš„æœåŠ¡å¯¼å‘è®¾è®¡
- **æ ¸å¿ƒåŠŸèƒ½**: âœ… ç†è§£ã€æ‰§è¡Œã€å·¥å…·ã€æŒ‡æ ‡ã€ç›‘æ§
- **æ¥å£**: âœ… åŒæ¥å£ç³»ç»Ÿï¼ˆRust API + HTTP RESTï¼‰
- **å¹¶å‘æ€§**: âœ… å¸¦èµ„æºç®¡ç†çš„å¹¶å‘ä»»åŠ¡å¤„ç†
- **å¯æ‰©å±•æ€§**: âœ… æ˜“äºæ‰©å±•çš„å·¥å…·ç³»ç»Ÿ
- **é”™è¯¯å¤„ç†**: âœ… å…¨é¢çš„é”™è¯¯ç±»å‹å’Œé‡è¯•é€»è¾‘
- **é…ç½®**: âœ… æ–‡ä»¶å’Œç¯å¢ƒå˜é‡æ”¯æŒ
- **CLI**: âœ… äº¤äº’å¼å’Œæ‰¹å¤„ç†æ¨¡å¼
- **æœåŠ¡**: âœ… å¸¦å¥åº·ç›‘æ§çš„ç”Ÿäº§å°±ç»ª HTTP æœåŠ¡
- **éƒ¨ç½²**: âœ… Docker å®¹å™¨åŒ–å’Œéƒ¨ç½²è®¾ç½®
- **ç›‘æ§**: âœ… Prometheus æŒ‡æ ‡å’Œ Grafana é›†æˆ

## å®ç°ç»†èŠ‚

### 1. é¡¹ç›®ç»“æ„

```
src/
â”œâ”€â”€ lib.rs              # å…¬å…± API å¯¼å‡º
â”œâ”€â”€ main.rs             # åº”ç”¨ç¨‹åºå…¥å£ç‚¹
â”œâ”€â”€ types.rs             # æ ¸å¿ƒç±»å‹å®šä¹‰
â”œâ”€â”€ errors.rs           # é”™è¯¯ç±»å‹å’Œå¤„ç†
â”œâ”€â”€ config.rs            # é…ç½®ç®¡ç†
â”œâ”€â”€ models.rs            # è¯­è¨€æ¨¡å‹å®ç°
â”œâ”€â”€ tools.rs             # å·¥å…·ç³»ç»Ÿå’Œå®ç°
â”œâ”€â”€ understanding.rs      # ç†è§£å¼•æ“
â”œâ”€â”€ execution.rs         # æ‰§è¡Œå¼•æ“
â”œâ”€â”€ agent.rs             # ä¸» CodeAgent
â””â”€â”€ cli.rs               # CLI æ¥å£
```

### 2. æ•°æ®æµ

```
ç”¨æˆ·è¾“å…¥ â†’ ç†è§£å¼•æ“ â†’ ä»»åŠ¡è®¡åˆ’ â†’ æ‰§è¡Œå¼•æ“ â†’ å·¥å…· â†’ ç»“æœ
```

### 3. å·¥å…·æ‰§è¡Œæµç¨‹

```
AI å†³ç­– â†’ å·¥å…·é€‰æ‹© â†’ å·¥å…·æ‰§è¡Œ â†’ ç»“æœ â†’ ä¸Šä¸‹æ–‡æ›´æ–° â†’ ä¸‹ä¸€æ­¥å†³ç­–
```

### 4. é…ç½®æ ¼å¼

```toml
# config.toml
[model]
provider = "zhipu"  # openai, anthropic, local
model_name = "GLM-4.6"
api_key = "${ZHIPU_API_KEY}"
endpoint = "https://open.bigmodel.cn/api/paas/v4/"
max_tokens = 4000
temperature = 0.7

[execution]
max_steps = 50
timeout_seconds = 300
max_retries = 3
retry_delay_seconds = 2

[safety]
enable_safety_checks = true
allowed_directories = [".", "/tmp"]
blocked_commands = ["rm -rf /", "format", "fdisk"]

[tools]
auto_discovery = true
custom_tools_path = "./tools"

[logging]
level = "info"
file = "agent.log"
```

## æ€»ç»“

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆçš„æ ¸å¿ƒä¼˜åŠ¿ï¼š

1. **çœŸæ­£çš„ AI-Native**: AI æ‹¥æœ‰å®Œå…¨çš„å†³ç­–è‡ªç”±
2. **æ¨¡å‹æ— å…³**: ä¸ç»‘å®šç‰¹å®šçš„ AI æä¾›å•†
3. **æœåŠ¡å¯¼å‘æ¶æ„**: ç”Ÿäº§å°±ç»ªçš„åŒæ¥å£ï¼ˆRust API + HTTP RESTï¼‰
4. **æç®€è®¾è®¡**: ä¸“æ³¨æ ¸å¿ƒåŠŸèƒ½ï¼Œé¿å…è¿‡åº¦å¤æ‚
5. **å¼€æ”¾æ¶æ„**: ä¸ä¾èµ–ç‰¹å®šçº¦å®šï¼Œé«˜åº¦å¯æ‰©å±•
6. **é«˜å¯é æ€§**: å®Œå–„çš„å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
7. **æ˜“äºç»´æŠ¤**: æ¸…æ™°çš„æ¨¡å—è¾¹ç•Œå’Œç®€å•çš„æ¥å£
8. **ç”Ÿäº§å°±ç»ª**: Docker éƒ¨ç½²ã€å¥åº·æ£€æŸ¥å’Œç›‘æ§
9. **è¯­è¨€æ— å…³**: HTTP API æ”¯æŒä»»ä½•ç¼–ç¨‹è¯­è¨€é›†æˆ
10. **å¯æ‰©å±•è®¾è®¡**: å¸¦èµ„æºç®¡ç†çš„å¹¶å‘ä»»åŠ¡å¤„ç†

è¿™ä¸ªè®¾è®¡ä¸ºæ„å»ºä¸€ä¸ªçœŸæ­£æ™ºèƒ½ã€çµæ´»ã€å¯é çš„ä»£ç åŠ©æ‰‹ç³»ç»Ÿå¥ å®šäº†åŸºç¡€ï¼Œè¯¥ç³»ç»Ÿå¯ä»¥ä½œä¸ºç‹¬ç«‹æœåŠ¡éƒ¨ç½²ã€‚é€šè¿‡æ¨¡å—åŒ–æ¶æ„å’Œæ¸…æ™°çš„æ¥å£è®¾è®¡ï¼Œç³»ç»Ÿå¯ä»¥è½»æ¾é€‚åº”å’Œæ‰©å±•åˆ°ä¸åŒçš„ä½¿ç”¨åœºæ™¯ï¼ŒåŒæ—¶ä¿æŒä¼ä¸šçº§çš„å¯é æ€§å’Œå¯è§‚å¯Ÿæ€§ã€‚

## å½“å‰çŠ¶æ€

AI-Native ä»£ç åŠ©æ‰‹**å·²å®ç°å¹¶å¯è¿è¡Œ**ï¼Œå…·å¤‡ï¼š
- âœ… éµå¾ªè®¾è®¡æ–‡æ¡£çš„å®Œæ•´æ¶æ„
- âœ… å·¥ä½œä¸­çš„ç†è§£å’Œæ‰§è¡Œå¼•æ“
- âœ… å¯æ‰©å±•çš„å·¥å…·ç³»ç»Ÿ
- âœ… å¤šæ¨¡å‹æä¾›å•†æ”¯æŒç»“æ„
- âœ… å…¨é¢çš„é”™è¯¯å¤„ç†
- âœ… é…ç½®ç®¡ç†
- âœ… CLI æ¥å£
- âœ… **å¸¦åŒæ¥å£çš„å®Œæ•´æœåŠ¡æ¶æ„**
- âœ… **å¸¦ç»¼åˆç«¯ç‚¹çš„ HTTP REST API**
- âœ… **ç”¨äºç›´æ¥é›†æˆçš„ Rust API åº“**
- âœ… **å¹¶å‘ä»»åŠ¡å¤„ç†å’Œèµ„æºç®¡ç†**
- âœ… **æŒ‡æ ‡æ”¶é›†å’Œç›‘æ§ç³»ç»Ÿ**
- âœ… **Docker éƒ¨ç½²é…ç½®**
- âœ… **å¥åº·ç›‘æ§å’ŒçŠ¶æ€æ£€æŸ¥**
- âœ… **ç”Ÿäº§å°±ç»ªçš„éƒ¨ç½²è®¾ç½®**

**ä¸‹ä¸€æ­¥ï¼š** åŸºç¡€å·²å®Œæˆå¹¶å¯æŠ•å…¥ç”Ÿäº§ä½¿ç”¨ã€‚æœåŠ¡æ¶æ„ä¸ºä»¥ä¸‹æ–¹é¢æä¾›äº†åšå®çš„åŸºç¡€ï¼š
- æ¨¡å‹ API é›†æˆå’Œæ›´å¤šå·¥å…·
- å¤„ç†ç”Ÿäº§å·¥ä½œè´Ÿè½½çš„æ‰©å±•
- é›†æˆåˆ°ç°æœ‰åº”ç”¨ç¨‹åºå’Œå·¥ä½œæµä¸­
- å¢å¼ºçš„ç›‘æ§å’Œå¯è§‚å¯Ÿæ€§åŠŸèƒ½
- é«˜çº§è®¤è¯å’Œæˆæƒæœºåˆ¶